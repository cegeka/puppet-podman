# @summary manage a podman container and register as a systemd service
#
# All flags for the 'podman container create' command are supported via the
# 'flags' hash parameter, using only the long form of the flag name.  The
# container name will be set as the resource name (namevar) unless the 'name'
# flag is included in the flags hash.
#
# When a container is created, a systemd unit file for the container service is
# generated using the 'podman generate systemd' command.  All flags for the
# command are supported using the 'service_flags" hash parameter, again using
# only the long form of the flag names.
#
# @example
#   podman::container { 'jenkins':
#     image         => 'docker.io/jenkins/jenkins',
#     flags         => {
#                      publish => [
#                                 '8080:8080',
#                                 '50000:50000',
#                                 ],
#                      volume  => 'jenkins:/var/jenkins_home',
#                      },
#     service_flags => {
#                      timeout => '60',
#                      },
#   }

define podman::container (
  String $image,
  Hash $flags         = {},
  Hash $service_flags = {},
  String $command     = '',
  String $ensure      = 'present',
  Boolean $enable     = true,
  Boolean $update     = true,
  String $user        = '',
  String $homedir     = '',
){
  # Add a label of base64 encoded flags defined for the container resource
  # This will be used to determine when the resource state is changed
  $flags_base64 = base64('encode', inline_template('<%= @flags.to_s %>')).chomp()

  # Add the default name and a custom label using the base64 encoded flags
  if has_key($flags, 'label') {
    $label = [] + $flags['label'] + "puppet_resource_flags=${flags_base64}"
    $no_label = $flags.delete('label')
  } else {
    $label = "puppet_resource_flags=${flags_base64}"
    $no_label = $flags
  }
  $merged_flags = merge({ name => $title, label => $label}, $no_label )
  $container_name = $merged_flags['name']

  # Convert $merged_flags hash to usable command arguments
  $_flags = $merged_flags.reduce('') |$mem, $flag| {
    if $flag[1] =~ String {
      "${mem} --${flag[0]} '${flag[1]}'"
    } else {
      $dup = $flag[1].reduce('') |$mem2, $value| {
        "$mem2 --${flag[0]} '${value}'"
      }
      "${mem} ${dup}"
    }
  }
 
  if $user != '' {
    if $homedir == '' { fail("Running as user ${user} requires 'homedir' parameter") }
    Exec {
      user        => $user,
      environment => [
                     "HOME=${homedir}",
                     ],
    }
  }


  case $ensure {
    'present': {
      # Re-deploy when the resource properties have changed
      if has_key($facts['podman_containers'], $container_name) and
        $facts['podman_containers'][$container_name]['puppet_resource_flags'] != $flags_base64 {
        notify{"redeploy_container_${container_name}":
          message => "Re-deploying due to changed resource parameters",
        }
        $updated_resource = true
      } else {
        $updated_resource = false
      }

      # Re-deploy when the container image has been updated
      if $update and has_key($facts['podman_containers'], $container_name) {
        $running_digest = $facts['podman_containers'][$container_name]['running_digest']
        $latest_digest = $facts['podman_containers'][$container_name]['latest_digest']
        if $running_digest != $latest_digest {
          notify{"redeploy_container_${container_name}":
            message => "Re-deploying for a container image update",
          }
          $updated_image = true
        } else {
          $updated_image = false
        }
      }

      if $updated_resource or $updated_image {
        Podman::Rm { $container_name:
          notify => Exec["podman_create_container_${container_name}"], 
        }
        if $updated_image {
          Podman::Image { "remove_image_${container_name}":
            ensure => 'absent',
            image  => $image,
            notify => Exec["podman_create_container_${container_name}"], 
          }
        }
      }

      Exec { "podman_create_container_${container_name}":
        path     => '/sbin:/usr/sbin:/bin:/usr/bin',
        command  => "podman container create ${_flags} ${image} ${command}",
        unless   => "podman container exists ${container_name}",
        notify   => Exec["podman_container_${container_name}_service"],
      }
    
      # Convert $service_flags hash to command arguments
      $_service_flags = $service_flags.reduce('') |$mem, $flag| {
        "$mem --${flag[0]} \"${flag[1]}\""
      }

      Exec { "podman_container_${container_name}_service":
        path        => '/sbin:/usr/sbin:/bin:/usr/bin',
        command     => @("END"/L),
                       podman generate systemd ${_service_flags} ${container_name} \
                        > "/etc/systemd/system/podman-${container_name}.service"
                       |END
        refreshonly => true,
        notify      => [
                       Exec['podman_systemd_reload'],
                       Service["podman-${container_name}"],
                       ],
      }
    
      # Configure the container service per parameters
      if $enable { $running = 'running' } else { $running = 'stopped' }
      Service { "podman-${container_name}":
        ensure  => $running,
        enable  => $enable,
        require => Exec['podman_systemd_reload'],
      }
    }

    'absent': {
      Podman::Rm { $container_name: }
    }

    default: {
      fail('"ensure" must be "present" or "absent"')
    }
  }


  # Reload systemd when service files are updated
  ensure_resource('Exec', 'podman_systemd_reload', {
                                            path        => '/sbin:/usr/sbin:/bin:/usr/bin',
                                            command     => 'systemctl daemon-reload',
                                            refreshonly => true,
                                            }
  )

}
